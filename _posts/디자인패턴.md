---
title: 디자인 패턴
layout: post
post-image: /assets/images/TIL.jpeg
description: CS, 디자인 패턴, 객체지향(OOP)
tags:
- CS
- 디자인 패턴
- 객체지향(OOP)
---

# 📖 디자인 패턴
- 소프트웨어를 설계할 때 특정 맥락에서 자주 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 재사용해 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것
- SW 재사용성, 호환성, 유지 보수성을 보장.

## 👉 <span style="background-color:#F15F5F; color:#fff;">디자인 패턴 구조</span>
**콘텍스트(context)**<br>
- 문제가 발생하는 여러 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다.
- 경웨 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.

**문제(problem)**<br>
- 문제가 발생하는 여러 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다.
- 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.

**해결(solution)**<br>
- 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다.
- 해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.

## 👉 <span style="background-color:#F15F5F; color:#fff;">디자인 패턴 분류</span>
| 생성(Creational)패턴 | 구조(Structural)패턴 | 행위(Behavioral)패턴 |
|:----------|:----------|:----------|
| - 추상 팩토리<br> - 빌더<br> - 팩토리메서드 <br> - 프로토타입 <br> - 싱글톤  | - 어댑터<br> - 브리지<br> - 컴퍼지트 <br> - 데커레이터<br> - 퍼사드<br> - 플라이웨이트<br> - 프록시 
| - 책임 연쇄 <br> - 커맨드<br> - 인터프리터<br> - 이터레이터<br> - 미디에이터<br> - 메멘토<br> - 옵서버<br> - 테이트<br> - 스트래티지<br> - 템플릿 메서드<br> - 비지터| 


### 💁‍♀️ <span style="background-color:#F2CB31; color:#2c2c2c;">생성(Creational)패턴</span>
> - 객체 생성에 관련된 패턴
- 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.
<!-- - **width를 따로 선언한 경우**, 남은 공간은 margin이 채워짐<br>(영역을 침범 당하지 않기 위해서)
- block의 경우 width, height, padding, border, margin을 모두 사용할 수 있다.
- block type을 **가운데 정렬하는 방법 : margin : 0 auto** 👉 margin top과 bottom은 0을 주고 right와 left는 auto (남는 px를 자동으로 채움)를 준다는 것이다. *별도로 margin left : auto;만 주면 block은 오른쪽 정렬이 된다.* -->

<!-- #### ✍️ 예시) 부모의 width가 1000px이라고 가정 후, 자식 width를 600px로 지정하면 남은 400px이 자동적으로 margin으로 채워진다. -->

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">구조(Structural)패턴</span>
> - 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
- 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">행위(Behavioral)패턴</span>
> - 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
- 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.


### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">디자인 패턴의 종류 </span>
**1. 생성(Creational)패턴**<br>

| 패턴 | 속성 | 
|:----------|:----------:|
| 추상 팩토리(Abstract Factory) | 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴 |
| 팩토리 메서드(Factory Method) | 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴 |
| 싱글톤(Singleton) | 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴 |

<br>

**2. 구조(Structural)패턴**<br>

| 패턴 | 속성 | 
|:----------|:----------:|
| 컴퍼지트(Composite) | 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴 |
| 데커레이터(Decorator) | 객체의 결합을 통해 기능을 동적으로 유연하게 활장할 수 있게 해주는 패턴 |

<br>

**3. 행위(Behavioral)패턴**<br>

| 패턴 | 속성 | 
|:----------|:----------:|
| 옵서버(Observer) | 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴 |
| 스테이트(State) | 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴 |
| 스트래티지(Strategy) | 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴 |
| 템플릿 메서드(Template Method) | 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바뀌지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴 |
| 커맨드(Command) | 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴 |

<br>

## 👉 <span style="background-color:#F15F5F; color:#fff;">객체지향개발(OOP) 개념 정리</span>

객체지향개발(Object Oriented Programming)의 특성은 크게 **추상화, 캡슐화, 상속성, 다향성**이 있다.

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">1) 추상화 </span>
> - 공통의 속성이나 기능을 묶어 이름을 붙이는 것
- 객체 지향적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴 수 있겠다.
- 좀 더 살펴보면 물고기, 사자, 토끼, 뱀이 있을때 우리는 이것들을 각각의 객체라 하며 이 객체들을 하나로 묶으려 할때, <br>
만약 동물 또는 생물이라는 어떤 추상적인 객체로 크게 정의한다고 하자. 이때 동물 또는 생물이라고 묶는 것을 추상화라고 한다.

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">2) 캡슐화 </span>
> - 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것. 다시 한번 말하자면 별수와 함수를 하나로 묶는것을 말한다.
- 하지만 무작정 한대 묶으면 되는 것이 아니라 **객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다**고 생각해야한다. 이것이 은닉화라고 한다.
- 또한 데이터를 절대로 외부에서 직접 접근을 하면 안되고 오로지 함수를 통해서만 접근해야하는데 이를 가능하게 해주는 것이 바로 캡슐화이다.
- 따라서 캡슐화에 성공하면 당연히 은닉화도 자연스럽게 효력이 나타난다.

<pre>
    public String test () {
        string aa = "aaa";
    }
</pre>

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">3) 상속성, 재사용(Inheritance) </span>
> - 상위 개념의 특징을 하위 개념이 물려받는 것
- 객체지향의 하이라이트 부분이라고 생각한다. 상속이란 개념이 없으면 객체지향이나 절차지향이나 거기서 거기
- 예를 들면, 자동차라는 부모 클래스가 있다. 기름을 먹거나 달리는 기능을 하는 자동차인데, 만약 뚜껑이 열리는 특수한 기능을 추가하고 싶다면 기존의 자동차에서 스포츠카를 생성한다.<br>
그러면 스포츠카는 기름도 먹고 달리면서 지붕뚜껑이 열리는 기능도 갖춘 자동차가 되는 것.

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">4) 다형성(Polymorphism)</span>
> - 부모클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것
- 예를 들면, mac이라는 운영체제를 사용하고 동기는 window라는 운영체제를 사용한다. cto님이 작업물 commit하세요! 라고 말씀하시면,<br>
나와 동기는 말씀을 듣고 commit을 한다. 이때 cto님은 추상적 객체를 상속받은 모든 객체들에게 명령을 내린것이고 그 직원들 운영체제가 뭐든간에 commit하라는 지시를 내린것이다.<br>
즉, 다형성이 없다면 mac을 사용하는 직원 commit, window를 사용하는 직원 commit이라며 지시를 하나하나 내려야 할 것이다.


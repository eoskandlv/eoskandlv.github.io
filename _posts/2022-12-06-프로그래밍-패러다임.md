---
title: 프로그래밍 패러다임
layout: post
post-image: /assets/images/TIL.jpeg
description: CS, 선언형, 함수형, 객체지향, 절차지향, OOP
tags:
- CS
- 선언형
- 함수형
- 객체지향
- 절차지향
- OOP
---

# 📖 프로그래밍 패러다임
- 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론, 간단하게 프로그래밍 스타일을 의미하며 전체적인 프로그래밍 방식을 말한다.
- 프로그램은 순차, 분기, 반복, 참조로 구성되어지며 프로그램 개발을 위해 전략을 수립해야 한다.
- 위에서 말한 전력은 어떤 언어를 사용할지, 프로그래밍에서 어떤 것을 지양하고, 지양할지 등 다양한 방법을 수립하게 된다. 여기서 말한 전략에 해당되는 내용들이 프로그래밍 패러다임이다.
- 프로그래밍 패러다임은 크게 **선언형**, **명령형**으로 나누며, 선언형은 함수형이라는 하위 집합을 갖고 명령형은 객체지향, 절차적으로 나눈다. 

## 👉 <span style="background-color:#F15F5F; color:#fff;">명령형  프로그래밍</span>
- 알고리즘을 명시하고 목표는 명시하지 않는다.
- 명령형은 어떻게 할 것인지 설명한다(how)
> ex) 명령으로 사람에게 지시
-> 횡단보도까지 약 5m 이동하고, 초록불일 때까지 기다렸다가 초록불이면 약 10m 앞으로 이동

**절차(순차)적 프로그래밍**<br>
- 순차적인(위에서 아래로 순서대로 실행하게 만드는 프로그래밍) 명령 수행뿐만 아니라, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그램 패러다임(ex : c언어)
- 프로시전느 루틴이나 하위프로그램, 메서드, 함수형 프로그래밍의 함수와도 같은 의미를 지니고 있는데, 리턴이 없는 함수정도로 이해하면 좋다.

<pre>
    const stringNumber = '12345';
    let sum = 0;

    for (let i = 0; i < stringNumber.length; i += 1) {
    sum += stringNumber[i] - '0';
    }
</pre>

**객체 지향 프로그래밍(OOP)**<br>
- 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적 상호작용을 통해 로직을 구성하는 프로그래밍 방법.
- 해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.

## 👉 <span style="background-color:#F15F5F; color:#fff;">선언형 프로그래밍</span>
- 알고리즘을 명시하지 않고 목표만 명시한다.
- 선언형은 무엇을 할 것인지 정의(what)

> ex) 선언으로 사람에게 지시
-> 초록불이 되면 길을 건넌다.

**함수형 프로그래밍**
- 최소 단위가 함수이며, 함수를 통하여 새로운 데이터들을 만들어가며 파이프 형태로 프로그래밍 하는 방식
- 모든 데이터의 처리를 수학적 함수(function)의 계산으로 취급하여 결과 값을 받아보고자 하는 패러다임(함수 단위로 나눠지므로 재샤용성이 높다.)
- 모든 데이터는 불변상태(Immutab)이어야 한다.
- Immuntability을 지향하기에 동작을 예측하기 쉽고 Side Effects를 방지한다(SideEffect를 방지하므로 동시성 문제도 해결된다.)
- 작은 '순수 함수'들을 블록처럼 쌓아 로직을 구현하고 '고차 함수'를 통해 재사용성을 높인 프로그래밍 패러다임
- 루프보다는 재귀를 사용한다. for, while같은 루프보다는 함수안에 함수를 호출하는 재귀호출을 사용하는 방법을 사용한다.
- 코드를 간결하게 하고 가독성을 높여 로직에 집중시켜야한다.

<pre>
* Immutability(불변성)
- immutable객체 (변할 수 없는 객체)는 생성된 이후에는 바꿀 수 없는 객체이다.
- 불변성은 함수형 프로그래밍의 핵심 개념이다. 불변성이 없다면 프로그램의 데이터 흐름이 손실된다.
* Side Effects(부작용)
- 함수형 프로그래밍에서 부작용은 함수 반환 값을 제외하고 함수 호출 외부에서 볼 수 있는 상태 변경을 뜻한다.
- 함수형 프로그래밍 규칙에 따르면 함수는 함수 외부으 상태를 수정할 수 없게 다룬다.
</pre>

<pre>
    const stringNumber = '12345';

    console.log(
    stringNumber
        .split('')
        .map((x) => parseInt(x))
        .reduce((acc, cur) => acc + cur)
    );
</pre>

- 앞의 코드에서 reduce()는 '배열'만 받아서 누적한 결괏값을 반환하는 순수 함수 

#### 순수함수
- 출력이 입력에만 의존하는 것
- 동일한 입력에 항상 같은 값을 반환해야하며 프로그램의 실행에 영향을 미치지 않는 함수(다른말로 side effect가 없어야한다)를 뜻한다.

#### 일급객체
- 자바스크립트에서는 특별한 대우를 받는 일급 객체가 있다.
- 대표적으로는 함수가 있는데 자바스크립트에서는 함수는 아래와 같이 취급된다.
 1) 변수에 할당할 수 있다.
 2) 다른 함수의 인자로 절달할 수 있다.
 3) 다른 함수의 결과로서 리턴될 수 있다.

#### 고차함수
- 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것
- 함수를 인자로 받을 수 있고, 함수의 형태로 리턴할 수 있다.
- 함수는 변수에 저장할 수 있으며 함수를 담은 변수를 인자로 전달받을 수 있다. 또한 내부에서 변수 자체에 함수를 할당 할 수도 있다.


## 👉 <span style="background-color:#F15F5F; color:#fff;">객체지향개발(OOP) 개념 정리</span>

객체지향개발(Object Oriented Programming)의 특성은 크게 **추상화, 캡슐화, 상속성, 다향성**이 있다.

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">1) 추상화 </span>
> - 공통의 속성이나 기능을 묶어 이름을 붙이는 것
- 객체 지향적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴 수 있겠다.
- 좀 더 살펴보면 물고기, 사자, 토끼, 뱀이 있을때 우리는 이것들을 각각의 객체라 하며 이 객체들을 하나로 묶으려 할때, <br>
만약 동물 또는 생물이라는 어떤 추상적인 객체로 크게 정의한다고 하자. 이때 동물 또는 생물이라고 묶는 것을 추상화라고 한다.

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">2) 캡슐화 </span>
> - 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것. 다시 한번 말하자면 별수와 함수를 하나로 묶는것을 말한다.
- 하지만 무작정 한대 묶으면 되는 것이 아니라 **객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다**고 생각해야한다. 이것이 은닉화라고 한다.
- 또한 데이터를 절대로 외부에서 직접 접근을 하면 안되고 오로지 함수를 통해서만 접근해야하는데 이를 가능하게 해주는 것이 바로 캡슐화이다.
- 따라서 캡슐화에 성공하면 당연히 은닉화도 자연스럽게 효력이 나타난다.

<pre>
    public String test () {
        string aa = "aaa";
    }
</pre>

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">3) 상속성, 재사용(Inheritance) </span>
> - 상위 개념의 특징을 하위 개념이 물려받는 것
- 객체지향의 하이라이트 부분이라고 생각한다. 상속이란 개념이 없으면 객체지향이나 절차지향이나 거기서 거기
- 예를 들면, 자동차라는 부모 클래스가 있다. 기름을 먹거나 달리는 기능을 하는 자동차인데, 만약 뚜껑이 열리는 특수한 기능을 추가하고 싶다면 기존의 자동차에서 스포츠카를 생성한다.<br>
그러면 스포츠카는 기름도 먹고 달리면서 지붕뚜껑이 열리는 기능도 갖춘 자동차가 되는 것.

### 💁‍♀️  <span style="background-color:#F2CB31; color:#2c2c2c;">4) 다형성(Polymorphism)</span>
> - 부모클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩,오버로딩 되어 사용되는 것
- 예를 들면, mac이라는 운영체제를 사용하고 동기는 window라는 운영체제를 사용한다. cto님이 작업물 commit하세요! 라고 말씀하시면,<br>
나와 동기는 말씀을 듣고 commit을 한다. 이때 cto님은 추상적 객체를 상속받은 모든 객체들에게 명령을 내린것이고 그 직원들 운영체제가 뭐든간에 commit하라는 지시를 내린것이다.<br>
즉, 다형성이 없다면 mac을 사용하는 직원 commit, window를 사용하는 직원 commit이라며 지시를 하나하나 내려야 할 것이다.

**오버로딩**
- 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출
- '정적' 다형성

**오버라이딩**
- 부모클래스의 메서드와 같은 이름, 상위클래스로부터 상속받은 메서드를 하위클래스가 재정의
- '동적' 다형성

## 👉 <span style="background-color:#F15F5F; color:#fff;">객체지향 설계원칙(SOLID)</span>

**1. 단일 책임 원칙(Single Responsibility Principle)**
- 하나의 클래스는 하나의 역할만 해야 함(A라는 로직이 존재한다면 어떠한 클래스는 A의 관한 클래스여야 하고 이를 수정한다고 헀을 때도 A와 관련된 수정이여야 함)

**2.개방-폐쇄 원칙(Open-Close Principle)**
- 확장(상속)에는 열려있고, 수정에는 닫혀 있어야 함(즉, 기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 함)

**3.리스코프 치환 원칙(Liskov Substitution Principle)**
- 자식이 부모의 자리에 항상 교체될 수 있어야 함
- 프로그램의 정확성으 ㄹ깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함

**4.인터페이스 분리 원칙(Interface Segregation Principle)**
- 인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야함
- 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙

**5.의존 역전 원칙(Dependency Inversion Property)**
- 상위 모듈이 하위 모듈에 의존하면 안되고 둘 다 추상화에 의존하며, 추상화는 세부 사항에 의존하면 안됨
- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 수운 것의 변화에 영향받지 않게 하는 원칙
- 예를 들어 타이어를 갈아끼울 수 있는 틀을 만들어 놓은 후 다양한 타이어를 교체할 수 있어야 한다




